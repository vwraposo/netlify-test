"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyUserHeadersTransform = exports.cacheHeadersByPath = exports.preloadHeadersByPath = exports.emptyHeadersMapForFiles = exports.addStaticCachingHeader = exports.addPublicCachingHeader = void 0;
const path_1 = require("path");
const kebab_hash_1 = __importDefault(require("kebab-hash"));
const constants_1 = require("./constants");
function preloadHeadersByPath(pages, manifest, pathPrefix) {
    return Object.fromEntries(pages.map((page) => {
        const scripts = [].concat(...constants_1.COMMON_BUNDLES.map((file) => getScriptsPaths(file, manifest)));
        scripts.push(...getScriptsPaths(pathChunkName(page.path), manifest));
        scripts.push(...getScriptsPaths(page.componentChunkName, manifest));
        const jsons = [
            path_1.posix.join(constants_1.PAGE_DATA_DIR, 'app-data.json'),
            getPageDataPath(page.path),
        ];
        return [
            normalizePath(pathPrefix + page.path),
            [
                ...scripts.filter(Boolean).map((script) => ({
                    name: 'Link',
                    value: linkTemplate(script, pathPrefix),
                })),
                ...jsons.map((json) => ({
                    name: 'Link',
                    value: linkTemplate(json, pathPrefix, 'fetch'),
                })),
            ],
        ];
    }));
}
exports.preloadHeadersByPath = preloadHeadersByPath;
function cacheHeadersByPath(pages, manifest) {
    const chunks = pages.map((page) => page.componentChunkName);
    chunks.push(`pages-manifest`, `app`);
    const files = [].concat(...chunks.map((chunk) => manifest[chunk] || []));
    return Object.fromEntries(files
        .map((file) => [`/${file}`, [constants_1.IMMUTABLE_CACHING_HEADER]])
        .concat(constants_1.CACHING_HEADERS));
}
exports.cacheHeadersByPath = cacheHeadersByPath;
// removes trailing slash if possible
function normalizePath(path) {
    if (!path.endsWith('/') || path === '/') {
        return path;
    }
    return path.slice(0, -1);
}
function getScriptsPaths(file, manifest) {
    const chunks = manifest[file];
    if (!chunks) {
        return [];
    }
    return chunks.filter((script) => path_1.parse(script).ext === '.js');
}
function linkTemplate(asset, pathPrefix, type = 'script') {
    return `<${pathPrefix}/${asset}>; rel=preload; as=${type}${type === 'fetch' ? '; crossorigin' : ''}`;
}
function pathChunkName(path) {
    const name = path === '/' ? 'index' : kebab_hash_1.default(path);
    return `path---${name}`;
}
function getPageDataPath(path) {
    const fixedPagePath = path === `/` ? `index` : path;
    return path_1.posix.join(constants_1.PAGE_DATA_DIR, fixedPagePath, `page-data.json`);
}
function applyUserHeadersTransform(headersMap, transform) {
    return Object.fromEntries(Object.entries(headersMap).map(([path, headers]) => {
        const headersAsStrings = headers.map(({ name, value }) => `${name}: ${value}`);
        return [path, transform(headersAsStrings, path).map(headerFromString)];
    }));
}
exports.applyUserHeadersTransform = applyUserHeadersTransform;
function addPublicCachingHeader(headersMap) {
    return Object.fromEntries(Object.entries(headersMap).map(([path, headers]) => {
        if (headers.find((h) => h.name.toLowerCase() === 'cache-control')) {
            return [path, headers];
        }
        return [path, [...headers, constants_1.PUBLIC_CACHING_HEADER]];
    }));
}
exports.addPublicCachingHeader = addPublicCachingHeader;
function addStaticCachingHeader(headersMap) {
    return Object.fromEntries(Object.entries(headersMap).map(([path, headers]) => {
        if (!path.startsWith('/static')) {
            return [path, headers];
        }
        return [path, [...headers, constants_1.IMMUTABLE_CACHING_HEADER]];
    }));
}
exports.addStaticCachingHeader = addStaticCachingHeader;
function headerFromString(header) {
    const [name, ...rest] = header.split(':');
    return {
        name,
        value: rest.join('').trim(),
    };
}
function emptyHeadersMapForFiles(files) {
    return Object.fromEntries(files.map((file) => [normalizePath(`/${removeIndexSuffix(file)}`), []]));
}
exports.emptyHeadersMapForFiles = emptyHeadersMapForFiles;
/** Any file ending with index.html might have a corresponding gatsby page.
 * Since we want these empty headers to be substituted by their page's headers
 * and to not create duplicate nginx directives for index.html files, we
 * remove the index.html suffix.
 * Any static, not-generated-by-gatsby, index.html file will still make its way to the
 * nginx configuration file, which when generated will try to match the header
 * entry with the list of files in the public directory. The only caveat is that
 * they will be served under a path without the 'index.html'.
 */
function removeIndexSuffix(path) {
    if (!path.endsWith(constants_1.INDEX_HTML)) {
        return path;
    }
    return path.slice(0, -constants_1.INDEX_HTML.length);
}
