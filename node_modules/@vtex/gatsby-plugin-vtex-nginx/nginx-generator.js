"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNginxConfiguration = exports.generatePathLocation = exports.generateRedirects = exports.generateRewrites = exports.validateRedirect = exports.convertFromPath = exports.stringify = void 0;
const path_1 = require("path");
const constants_1 = require("./constants");
function generateNginxConfiguration(rewrites, redirects, headersMap, files, options) {
    const locations = [
        ...Object.entries(headersMap)
            .map(([path, headers]) => generatePathLocation(path, headers, files, options))
            .filter(function (value) {
            return value !== undefined;
        }),
        ...generateRedirects(redirects),
        ...generateRewrites(rewrites),
    ];
    const conf = options.writeOnlyLocations
        ? locations
        : [
            { cmd: ['worker_processes', '3'] },
            { cmd: ['worker_rlimit_nofile', '8192'] },
            { cmd: ['error_log', '/var/log/nginx_errors.log', 'debug'] },
            { cmd: ['pid', '/var/log/nginx_run.pid'] },
            {
                cmd: ['events'],
                children: [{ cmd: ['worker_connections', '1024'] }],
            },
            {
                cmd: ['http'],
                children: [
                    { cmd: ['access_log', '/var/log/nginx_access.log'] },
                    { cmd: ['include', '/etc/nginx/mime.types'] },
                    { cmd: ['default_type', 'application/octet-stream'] },
                    { cmd: ['disable_symlinks', 'off'] },
                    { cmd: ['sendfile', 'on'] },
                    { cmd: ['tcp_nopush', 'on'] },
                    { cmd: ['keepalive_timeout', '65'] },
                    { cmd: ['gzip', 'on'] },
                    {
                        cmd: [
                            'gzip_types',
                            'text/plain',
                            'text/css',
                            'text/xml',
                            'application/javascript',
                            'application/x-javascript',
                            'application/xml',
                            'application/xml+rss',
                            'application/emacscript',
                            'application/json',
                            'image/svg+xml',
                        ],
                    },
                    {
                        cmd: ['server'],
                        children: [
                            { cmd: ['listen', '0.0.0.0:$PORT', 'default_server'] },
                            { cmd: ['resolver', '8.8.8.8'] },
                            ...locations,
                        ],
                    },
                ],
            },
        ];
    return stringify(conf);
}
exports.generateNginxConfiguration = generateNginxConfiguration;
function stringify(directives) {
    return directives
        .map(({ cmd, children }) => `${cmd.join(' ')}${children ? ` {\n${ident(stringify(children))}\n}` : ';'}`)
        .join('\n');
}
exports.stringify = stringify;
function convertFromPath(path) {
    return `^${path.replace(/\*/g, '(.*)').replace(/:slug/g, '[^/]+')}`;
}
exports.convertFromPath = convertFromPath;
function convertToPath(path) {
    return path.replace(/:splat/g, '$1');
}
function validateRedirect({ fromPath, toPath }) {
    let url;
    try {
        url = new URL(toPath);
    }
    catch (ex) {
        throw new Error(`redirect toPath "${toPath}" must be a valid absolute URL`);
    }
    return true;
}
exports.validateRedirect = validateRedirect;
function generateRewrites(rewrites) {
    return rewrites.map(({ fromPath, toPath }) => {
        return {
            cmd: ['location', '~*', convertFromPath(fromPath)],
            children: [{ cmd: ['rewrite', '.+', toPath] }],
        };
    });
}
exports.generateRewrites = generateRewrites;
function formatProxyHeaders(headers) {
    return Object.keys(headers !== null && headers !== void 0 ? headers : {}).map((name) => {
        return { cmd: ['proxy_set_header', name, headers[name]] };
    });
}
function generateRedirects(redirects) {
    return redirects.map((redirect) => {
        validateRedirect(redirect);
        const { fromPath, toPath, headers } = redirect;
        return {
            cmd: ['location', '~*', convertFromPath(fromPath)],
            children: [
                ...formatProxyHeaders(headers),
                { cmd: ['proxy_pass', `${convertToPath(toPath)}$is_args$args`] },
                { cmd: ['proxy_ssl_server_name', 'on'] },
            ],
        };
    });
}
exports.generateRedirects = generateRedirects;
function storagePassTemplate(path, files, { serveFileDirective }) {
    path = path.slice(1); // remove leading slash
    const filePath = files.find((file) => file === path || file === path_1.posix.join(path, constants_1.INDEX_HTML));
    if (filePath === undefined) {
        return undefined;
    }
    return {
        cmd: serveFileDirective.map((part) => part.replace(/\$file/g, filePath)),
    };
}
function generatePathLocation(path, headers, files, options) {
    const proxyPassDirective = storagePassTemplate(path, files, options);
    if (proxyPassDirective === undefined) {
        return undefined;
    }
    return {
        cmd: ['location', '=', path],
        children: [
            ...headers.map(({ name, value }) => ({
                cmd: ['add_header', name, `"${value}"`],
            })),
            proxyPassDirective,
        ],
    };
}
exports.generatePathLocation = generatePathLocation;
function ident(text, space = '  ') {
    return text
        .split('\n')
        .map((line) => `${space}${line}`)
        .join('\n');
}
