"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceNodes = void 0;
const wrap_1 = require("@graphql-tools/wrap");
const graphql_1 = require("graphql");
const api_1 = require("./api");
const fetch_1 = require("./fetch");
const utils_1 = require("./utils");
const getGraphQLUrl = (tenant, workspace) => `http://${workspace}--${tenant}.myvtex.com/graphql`;
exports.sourceNodes = (args, options) => __awaiter(void 0, void 0, void 0, function* () {
    const { tenant, workspace } = options;
    const { actions: { addThirdPartySchema }, } = args;
    /**
     * VTEX GraphQL API
     * */
    // Create executor to run queries against schema
    const url = getGraphQLUrl(tenant, workspace);
    const executor = ({ document, variables }) => __awaiter(void 0, void 0, void 0, function* () {
        const query = graphql_1.print(document);
        const fetchResult = yield fetch(url, {
            method: 'POST',
            headers: {
                accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ query, variables }),
        });
        const result = yield fetchResult.json();
        /**
         * We've chosen to ignore the 404 errors on build time.
         * This allows us to complete builds with slightly old slugs and
         * to handle this type of error on the client, where we will make
         * some redirects.
         */
        if (result.errors && result.errors.length > 0) {
            result.errors = result.errors.filter((error) => {
                var _a, _b;
                console.warn(error);
                const status = (_b = (_a = error.extensions) === null || _a === void 0 ? void 0 : _a.exception) === null || _b === void 0 ? void 0 : _b.status;
                return !status || status !== 404;
            });
            if (result.errors.length === 0) {
                delete result.errors;
            }
        }
        return result;
    });
    const schema = wrap_1.wrapSchema({
        schema: yield wrap_1.introspectSchema(executor),
        executor,
    });
    addThirdPartySchema({ schema });
    /**
     * VTEX HTTP API fetches
     * */
    // Bindings
    const { bindings } = yield fetch_1.fetchVTEX(api_1.api.tenants.tenant(tenant), options);
    bindings.forEach((binding) => utils_1.createChannelNode(args, binding));
    // Catetgories
    const departments = yield fetch_1.fetchVTEX(api_1.api.catalog.category.tree(1), options);
    departments.forEach((department) => utils_1.createDepartmentNode(args, department));
});
