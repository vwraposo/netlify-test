"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentDOM = void 0;
const cms_1 = require("./cms");
const parseBlockName = (name) => {
    const splitted = name.split('/');
    if (splitted.length === 1) {
        return {
            component: splitted[0],
        };
    }
    const dependency = splitted.slice(0, splitted.length - 1).join('/');
    const component = splitted[splitted.length - 1];
    return {
        dependency,
        component,
    };
};
class ContentDOM {
    constructor(content) {
        this.content = content;
        this.renderToString = () => {
            let afterBlocksStr;
            let beforeBlocksStr;
            const { blocks, beforeBlocks, afterBlocks } = this.content;
            const blocksStr = this.renderBlocksToString(blocks);
            if (beforeBlocks) {
                beforeBlocksStr = this.renderBlocksToString(beforeBlocks);
            }
            if (afterBlocks) {
                afterBlocksStr = this.renderBlocksToString(afterBlocks);
            }
            const imports = this.renderImportsToString();
            return `
import React, { FC } from 'react'

${imports}

const CMSAutogenPage: FC = () => (
  <>
    ${beforeBlocksStr}
    ${blocksStr}
    ${afterBlocksStr}
  </>
)

export default CMSAutogenPage
`;
        };
        this.renderImportsToString = () => {
            let imports = '';
            for (const [component, dep] of this.meta.imports.entries()) {
                const statement = `import ${component} from '${dep}'`;
                imports = `${imports}\n${statement}`;
            }
            return imports;
        };
        this.renderBlocksToString = (blocks) => {
            if (!blocks)
                return;
            const inner = blocks.map((b) => this.renderBlockToString(b)).join('\n');
            return `${inner}`;
        };
        this.renderBlockToString = (block) => {
            const { name, props } = block;
            const { component, dependency } = parseBlockName(name);
            const propsStr = this.propsToString(props);
            // Extract meta info from block
            // Sometimes the component is just a <div> or some other
            // builtin component. Let's not import a div in import
            // statements
            if (dependency) {
                // Add block into page imports
                this.meta.imports.set(component, name);
            }
            let inner;
            const { children } = props;
            if (cms_1.isBlock(children)) {
                inner = this.renderBlockToString(children);
            }
            else if (Array.isArray(children) && children.every(cms_1.isBlock)) {
                inner = this.renderBlocksToString(children);
            }
            return `<${component} ${propsStr}>${inner !== null && inner !== void 0 ? inner : ''}</${component}>`;
        };
        this.propsToString = (props = {}) => Object.keys(props).reduce((acc, propName) => {
            if (propName === 'children') {
                return acc;
            }
            const prop = props[propName];
            let propStr = '';
            if (typeof prop === 'string') {
                propStr = `"${prop}"`;
            }
            else if (typeof prop === 'number' || typeof prop === 'boolean') {
                propStr = `${prop}`;
            }
            else if (typeof prop === 'object') {
                propStr = `{${JSON.stringify(prop)}}`;
            }
            else {
                throw new Error(`Unknown type ${typeof prop} while generating code for prop ${propName}`);
            }
            return `${acc} ${propName}=${propStr}`;
        }, '');
        this.meta = {
            imports: new Map(),
        };
    }
}
exports.ContentDOM = ContentDOM;
