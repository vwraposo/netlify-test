"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onCreatePage = exports.onCreateWebpackConfig = exports.sourceNodes = void 0;
const fs_extra_1 = require("fs-extra");
const cli_1 = require("@formatjs/cli");
const path_1 = require("./helpers/path");
const localesArrayDefault = ['en'];
exports.sourceNodes = (args, options) => __awaiter(void 0, void 0, void 0, function* () {
    const { actions: { createNode }, createNodeId, createContentDigest, reporter, } = args;
    const { messagesPath, locales = localesArrayDefault, defaultLocale = 'en', } = options;
    if (messagesPath == null) {
        reporter.panicOnBuild('Please provide the path to the JSON files with translations');
        return;
    }
    if (!locales.includes(defaultLocale)) {
        reporter.panicOnBuild('Please provide a default locale that is contained in your provided locales array');
        return;
    }
    for (const locale of locales) {
        let languageJson = null;
        try {
            languageJson = yield fs_extra_1.readJSON(`${messagesPath}/${locale}.json`, {
                encoding: 'utf-8',
            });
        }
        catch (e) {
            languageJson = null;
        }
        if (languageJson == null && locale === defaultLocale) {
            reporter.panicOnBuild(`Error reading strings for default locale`);
            return;
        }
        if (languageJson == null) {
            reporter.info(`Error reading strings for locale ${locale}`);
            continue;
        }
        const withDefaultMessage = Object.entries(languageJson).reduce((acc, [key, val]) => {
            acc[key] = { defaultMessage: val };
            return acc;
        }, {});
        yield fs_extra_1.outputFile(`${messagesPath}/${locale}-temp.json`, JSON.stringify(withDefaultMessage));
        const resultAsString = yield cli_1.compile([`${messagesPath}/${locale}-temp.json`], { ast: true });
        yield fs_extra_1.unlink(`${messagesPath}/${locale}-temp.json`);
        const data = { messages: resultAsString, locale };
        createNode(Object.assign(Object.assign({}, data), { id: createNodeId(`LanguageData-${locale}`), internal: {
                type: 'LanguageData',
                content: JSON.stringify(data),
                contentDigest: createContentDigest(data),
            } }));
    }
    const languageDataConfig = {
        locales,
        defaultLocale,
    };
    createNode(Object.assign(Object.assign({}, languageDataConfig), { id: createNodeId(`LanguageDataConfig`), internal: {
            type: 'LanguageDataConfig',
            content: JSON.stringify(languageDataConfig),
            contentDigest: createContentDigest(languageDataConfig),
        } }));
});
exports.onCreateWebpackConfig = ({ actions }) => {
    actions.setWebpackConfig({
        resolve: {
            alias: {
                'react-intl$': 'react-intl/react-intl-no-parser.umd',
            },
        },
    });
};
exports.onCreatePage = ({ page, actions, getNodesByType, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { createPage, deletePage } = actions;
    // Check if originalPath was already set and bail early as otherwise an infinite loop could occur
    // as other plugins like gatsby-plugin-mdx could modify this
    if (page.context.originalPath) {
        return;
    }
    const originalPath = page.path;
    deletePage(page);
    const languageNodes = getNodesByType('LanguageData');
    const languageConfig = getNodesByType('LanguageDataConfig')[0];
    const { defaultLocale } = languageConfig;
    for (const languageData of languageNodes) {
        const { locale, messages } = languageData;
        createPage(Object.assign(Object.assign({}, page), { path: path_1.localizedPath(defaultLocale, locale, page.path), matchPath: page.matchPath
                ? path_1.localizedPath(defaultLocale, locale, page.matchPath)
                : page.matchPath, context: Object.assign(Object.assign({}, page.context), { messages: JSON.parse(messages || ''), locale,
                defaultLocale,
                originalPath }) }));
    }
});
