"use strict";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class RenderExtensionLoader {
    constructor({ account, workspace, path, locale, publicEndpoint, verbose, timeout, }) {
        this.getRuntimeContext = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.runtime) {
                yield this.loadExtensionPointsContext();
            }
            return {
                runtime: this.runtime,
                scripts: this.scripts,
                styles: this.styles,
            };
        });
        this.load = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.runtime) {
                yield this.loadExtensionPointsContext();
            }
            if (this.styles) {
                this.styles.forEach(this.addStyleToPage);
            }
            this.time('render-extension-loader:scripts');
            yield Promise.all(this.scripts.map(this.addScriptToPage));
            this.timeEnd('render-extension-loader:scripts');
            return this.runtime;
        });
        this.update = (runtimeOrUpdateFn) => {
            if (typeof runtimeOrUpdateFn === 'function') {
                this.runtime = runtimeOrUpdateFn(this.runtime);
            }
            else {
                this.runtime = Object.assign(Object.assign({}, this.runtime), runtimeOrUpdateFn);
            }
            return this.runtime;
        };
        this.render = (extension, element, props) => {
            if (props) {
                this.runtime.extensions[extension].props = Object.assign(Object.assign({}, this.runtime.extensions[extension].props), props);
            }
            this.time('render-extension-loader:render');
            const runtime = window[`__RENDER_${this.renderMajor}_RUNTIME__`];
            runtime.render(extension, this.runtime, element);
            this.timeEnd('render-extension-loader:render');
            return this.runtime;
        };
        this.loadExtensionPointsContext = () => __awaiter(this, void 0, void 0, function* () {
            this.time('render-extension-loader:json');
            const { runtime, styles, scripts } = yield this.get(`https://${this.workspace}--${this.account}.${this.publicEndpoint}/legacy-extensions${this.path}?__disableSSR&locale=${this.locale}&v=3&origin=${window.location.hostname}`);
            this.timeEnd('render-extension-loader:json');
            for (const key in window.__RUNTIME__ || {}) {
                if (Object.prototype.hasOwnProperty.call(window.__RUNTIME__, key) &&
                    runtime[key] === undefined) {
                    runtime[key] = window.__RUNTIME__[key];
                }
            }
            this.setGlobalContext({ runtime, styles, scripts });
            return { runtime, styles, scripts };
        });
        this.setGlobalContext = ({ runtime, styles, scripts }) => {
            this.renderMajor = runtime.renderMajor || 6;
            this.styles = styles;
            this.scripts = scripts;
            this.runtime = Object.assign(Object.assign({}, runtime), { start: false });
        };
        this.getExistingScriptSrcs = () => {
            const paths = [];
            for (let i = 0; i < document.scripts.length; i++) {
                paths.push(document.scripts.item(i).src);
            }
            return paths;
        };
        this.scriptOnPage = (path) => {
            return this.getExistingScriptSrcs().some((src) => src.indexOf(path) !== -1);
        };
        this.addScriptToPage = (src) => {
            return new Promise((resolve, reject) => {
                if (this.scriptOnPage(src)) {
                    return resolve();
                }
                const script = document.createElement('script');
                script.crossOrigin = 'anonymous';
                script.onload = () => resolve();
                script.onerror = () => reject();
                script.async = false;
                script.src = src;
                document.head.appendChild(script);
            });
        };
        this.addStyleToPage = (href) => {
            const link = document.createElement('link');
            link.href = href;
            link.type = 'text/css';
            link.rel = 'stylesheet';
            document.head.appendChild(link);
        };
        this.time = (label) => {
            if (this.verbose) {
                console.time(label);
            }
        };
        this.timeEnd = (label) => {
            if (this.verbose) {
                console.timeEnd(label);
            }
        };
        this.account = account;
        this.workspace = workspace;
        this.path = path;
        this.locale = locale || 'en-US';
        this.verbose = verbose;
        this.timeout = timeout;
        this.publicEndpoint =
            publicEndpoint ||
                (/myvtexdev\.com/.test(window.location.hostname)
                    ? 'myvtexdev.com'
                    : 'myvtex.com');
        this.get = window.$
            ? (url) => window.$.ajax({ url, timeout: this.timeout }).retry({
                timeout: 2000,
                times: 2,
            })
            : window.fetch
                ? (url) => new Promise((resolve, reject) => {
                    const fetchTimeout = setTimeout(() => {
                        reject({ error: 'timeout' });
                    }, this.timeout);
                    window
                        .fetch(url)
                        .then((res) => {
                        clearTimeout(fetchTimeout);
                        return res;
                    })
                        .then((res) => res.json())
                        .then((res) => resolve(res));
                })
                : null;
        if (!window.__RUNTIME__) {
            // This is the minimum necessary information for HMR to work and needs to be global.
            window.__RUNTIME__ = { account, workspace, publicEndpoint };
        }
        else {
            this.runtime = window.__RUNTIME__;
            this.renderMajor = 7;
        }
        if (!this.get) {
            throw new Error('Render Extension Loader requires either jQuery.ajax or window.fetch.');
        }
    }
}
exports.default = RenderExtensionLoader;
