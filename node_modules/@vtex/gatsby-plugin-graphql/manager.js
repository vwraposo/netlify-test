"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryManager = void 0;
/* eslint-disable max-params */
const assert_1 = __importDefault(require("assert"));
const crypto_1 = require("crypto");
const graphql_1 = require("graphql");
function hash(s) {
    return crypto_1.createHash('sha256').update(s, 'utf8').digest().toString('hex');
}
function isOperationDefinition(ob) {
    return Boolean(ob && ob.kind === 'OperationDefinition');
}
function isFragmentDefinition(ob) {
    return Boolean(ob && ob.kind === 'FragmentDefinition');
}
const isThirdPartyScript = (filename) => filename.includes('node_modules');
/**
 * In memory presentation of GraphQL queries that appear in the code
 */
class QueryManager {
    constructor() {
        /**
         * Queries by name
         */
        this.queries = new Map();
        /**
         * Fragments by name
         */
        this.fragments = new Map();
        /**
         * Fragments by query name
         */
        this.fragmentsUsedByQuery = new Map();
        /**
         * Fragments by fragment name
         */
        this.fragmentsUsedByFragment = new Map();
    }
    static getSingleton() {
        if (!global.QueryManager) {
            ;
            global.QueryManager = new QueryManager();
        }
        return global.QueryManager;
    }
    addQuery({ query: queryStr, filename, }) {
        const doc = graphql_1.parse(queryStr);
        graphql_1.visit(doc, {
            OperationDefinition: (def) => {
                if (!def.name) {
                    // We allow third party queries not to be named. This is ok
                    // since we don't support using them
                    if (isThirdPartyScript(filename)) {
                        return;
                    }
                    throw new Error('OperationDefinition missing name');
                }
                const queryName = def.name.value;
                assert_1.default(queryName.endsWith('Query') || queryName.endsWith('Mutation'), 'GraphQL OperationName should endsWith Query or Mutation');
                const query = graphql_1.print(def).trim();
                if (this.queries.get(queryName) !== undefined) {
                    console.warn(`Skipping query ${queryName} since it was already defined. If this wasn't the intended behavior please change your query operation name`);
                    return;
                }
                this.queries.set(queryName, { value: query, filename, name: queryName });
                this.fragmentsUsedByQuery.set(queryName, new Set());
            },
            FragmentDefinition: (def) => {
                const fragmentName = def.name.value;
                const fragment = graphql_1.print(def).trim();
                assert_1.default(fragmentName.split('_').length === 2, 'GraphQL Fragment should be named following the template <ComponentName>_<PropName>');
                if (this.fragments.get(fragmentName) !== undefined) {
                    console.warn(`Skipping query ${fragmentName} since it was already defined. If this wasn't the intended behavior please change your query operation name`);
                    return;
                }
                this.fragments.set(fragmentName, {
                    value: fragment,
                    filename,
                    name: fragmentName,
                });
                this.fragmentsUsedByFragment.set(fragmentName, new Set());
            },
            FragmentSpread: (node, key, parent, path, ancestors) => {
                var _a;
                const fragmentSpreadName = node.name.value;
                for (const a of ancestors) {
                    if (isFragmentDefinition(a)) {
                        const parentFragmentName = a.name.value;
                        let fragments = this.fragmentsUsedByFragment.get(parentFragmentName);
                        if (!fragments) {
                            fragments = new Set();
                            this.fragmentsUsedByFragment.set(parentFragmentName, fragments);
                        }
                        fragments.add(fragmentSpreadName);
                    }
                    if (isOperationDefinition(a)) {
                        const queryName = (_a = a.name) === null || _a === void 0 ? void 0 : _a.value;
                        if (!queryName) {
                            continue;
                        }
                        let fragments = this.fragmentsUsedByQuery.get(queryName);
                        if (!fragments) {
                            fragments = new Set();
                            this.fragmentsUsedByQuery.set(queryName, fragments);
                        }
                        fragments.add(fragmentSpreadName);
                    }
                }
            },
        });
    }
    ensureRequiredFragments(queryName) {
        const usedFragments = this.getUsedFragmentNamesForQuery(queryName);
        for (const fragmentName of usedFragments) {
            if (!this.fragments.has(fragmentName)) {
                throw new Error(`Could not find fragment ${fragmentName} for query ${queryName}`);
            }
        }
        return true;
    }
    getQueries() {
        const operationNames = Array.from(this.queries.keys());
        return operationNames.map((operationName) => {
            this.ensureRequiredFragments(operationName);
            return this.exportQuery(operationName);
        });
    }
    getFragments() {
        const fragments = Array.from(this.fragments.keys());
        return fragments.map((fragmentName) => {
            // TODO: Do something like ensureRequiredFragments in here
            return this.exportFragment(fragmentName);
        });
    }
    getUsedFragmentNamesForQuery(queryName) {
        const fragmentNames = new Set();
        const usedFragments = this.fragmentsUsedByQuery.get(queryName);
        if (!usedFragments) {
            return fragmentNames;
        }
        for (const usedFragmentName of usedFragments) {
            fragmentNames.add(usedFragmentName);
            this.getNestedFragmentNamesForFragment(usedFragmentName, fragmentNames);
        }
        return fragmentNames;
    }
    getNestedFragmentNamesForFragment(fragmentName, _fragments) {
        const fragments = _fragments !== null && _fragments !== void 0 ? _fragments : new Set();
        const usedFragments = this.fragmentsUsedByFragment.get(fragmentName);
        if (usedFragments) {
            for (const usedFragmentName of usedFragments) {
                fragments.add(usedFragmentName);
                this.getNestedFragmentNamesForFragment(usedFragmentName, fragments);
            }
        }
        return fragments;
    }
    exportQuery(operationName) {
        const queryNode = this.queries.get(operationName);
        if (!queryNode) {
            throw new Error(`Unknown query ${operationName}`);
        }
        const { value, filename } = queryNode;
        const fragments = Array.from(this.getUsedFragmentNamesForQuery(operationName))
            .map((f) => { var _a; return (_a = this.fragments.get(f)) === null || _a === void 0 ? void 0 : _a.value; })
            .join('\n');
        const fullQuery = `${value}\n${fragments}`.trim();
        return {
            name: operationName,
            sha256Hash: hash(fullQuery),
            value: fullQuery,
            filename,
        };
    }
    exportFragment(fragmentName) {
        const fragmentNode = this.fragments.get(fragmentName);
        if (!fragmentNode) {
            throw new Error(`Unknown fragment ${fragmentName}`);
        }
        const { value, filename } = fragmentNode;
        const fragments = Array.from(this.getNestedFragmentNamesForFragment(fragmentName))
            .map((f) => { var _a; return (_a = this.fragments.get(f)) === null || _a === void 0 ? void 0 : _a.value; })
            .join('\n');
        const resolvedFragment = `${value}\n${fragments}`.trim();
        return {
            name: fragmentName,
            value: resolvedFragment,
            filename,
        };
    }
}
exports.QueryManager = QueryManager;
