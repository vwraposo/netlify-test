"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFragments = exports.getQueries = exports.registerGQLListener = exports.getQuery = exports.gql = exports.request = exports.createRuntimeGQL = void 0;
const shared_1 = require("./shared");
function createRuntimeGQL() {
    const queries = {};
    const fragments = {};
    const listeners = [];
    function registerGQLListener(fn) {
        listeners.push(fn);
    }
    function gql(literals, ...placeholders) {
        if (!Array.isArray(literals)) {
            // Was converted to a normal function call via babel
            return runtimeGQL(literals);
        }
        throw new Error("babel-gql not configured?");
    }
    function runtimeGQL(parsed) {
        listeners.forEach((fn) => fn(parsed));
        parsed.queries.forEach((query) => {
            queries[query.queryName] = query;
        });
        parsed.fragments.forEach((fragment) => {
            fragments[fragment.fragmentName] = fragment;
        });
        return parsed;
    }
    function findFragmentsOfFragments(fragmentName, _frags) {
        const fragment = fragments[fragmentName];
        if (!fragment) {
            throw new Error(`Cannot find fragment ${fragmentName}`);
        }
        if (!_frags) {
            _frags = {};
        }
        _frags[fragmentName] = true;
        fragment.usedFragments.forEach((fragmenName) => {
            _frags[fragmenName] = true;
            findFragmentsOfFragments(fragmenName, _frags);
        });
        return _frags;
    }
    return {
        gql,
        runtimeGQL,
        registerGQLListener,
        getQueries() {
            return queries;
        },
        getFragments() {
            return fragments;
        },
        getQuery(queryName) {
            const query = queries[queryName];
            if (!query) {
                throw new Error(`Cannot find query ${queryName}`);
            }
            const frags = {};
            query.usedFragments.forEach((fragmentName) => {
                findFragmentsOfFragments(fragmentName, frags);
            });
            const usedFragments = Object.keys(frags).map((fragmentName) => {
                const fragment = fragments[fragmentName];
                if (!fragment) {
                    throw new Error(`Cannot find fragment ${fragmentName} for query ${queryName}`);
                }
                return fragment;
            });
            return {
                query: (usedFragments.map((f) => f.fragment).join("\n") +
                    "\n" +
                    query.query).trim(),
                queryName: queryName,
                queryId: shared_1.combinedIds([
                    query.queryId,
                    ...usedFragments.map((f) => f.fragmentId),
                ]),
            };
        },
    };
}
exports.createRuntimeGQL = createRuntimeGQL;
function doRequest(endpoint, options) {
    var _a, _b, _c;
    const ourFetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : fetch;
    if (process.env.NODE_ENV !== "production") {
        const { headers, ...otherOptions } = (_b = options.fetchOptions) !== null && _b !== void 0 ? _b : {};
        return ourFetch(endpoint, {
            method: "POST",
            headers: {
                "content-type": "application/json",
                ...(_c = options.fetchOptions) === null || _c === void 0 ? void 0 : _c.headers,
            },
            ...otherOptions,
            body: JSON.stringify({
                variables: options.variables,
                operationName: options.query.queryName,
                query: options.query.query,
            }),
        });
    }
    const params = new URLSearchParams();
    params.append("operationName", options.query.queryName);
    if (options.variables) {
        params.append("variables", JSON.stringify(options.variables));
    }
    params.append("extensions", JSON.stringify({
        persistedQuery: {
            version: 1,
            sha256Hash: options.query.queryId,
        },
    }));
    // XXX turn to POST if mutation
    return ourFetch(endpoint + "?" + params.toString(), options.fetchOptions);
}
function request(endpoint, options) {
    const query = options.query;
    if (typeof query !== "string") {
        if (query.queries.length === 0) {
            throw new Error("Cannot find graphql query from tag");
        }
        if (query.queries.length > 1) {
            console.warn("Multiple queries defined in request query " +
                query.queries.map((q) => q.queryName).join(", "));
        }
    }
    let promise;
    if (typeof query === "string") {
        promise = doRequest(endpoint, {
            query: exports.getQuery(query),
            variables: options.variables,
            fetch: options.fetch,
            fetchOptions: options.fetchOptions,
        });
    }
    else {
        const queryOb = query.queries[0];
        promise = doRequest(endpoint, {
            query: exports.getQuery(queryOb.queryName),
            variables: options.variables,
            fetch: options.fetch,
            fetchOptions: options.fetchOptions,
        });
    }
    let response;
    return promise
        .then((res) => {
        response = res;
        return res.json();
    })
        .then((data) => {
        var _a, _b;
        if ((_b = (_a = data.errors) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 > 0) {
            data.errors.forEach((error) => {
                console.error("GraphQL response error:", error.message, error);
            });
        }
        data.response = response;
        return data;
    });
}
exports.request = request;
const babelqgl = createRuntimeGQL();
exports.gql = babelqgl.gql;
exports.getQuery = babelqgl.getQuery;
exports.registerGQLListener = babelqgl.registerGQLListener;
exports.getQueries = babelqgl.getQueries;
exports.getFragments = babelqgl.getFragments;
//# sourceMappingURL=index.js.map