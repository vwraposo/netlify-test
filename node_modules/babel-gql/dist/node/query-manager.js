"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryManager = exports.BabelGQLWebpackPlugin = exports.findUsedFragments = exports.debug = exports.BABEL_GQL_GLOBAL = void 0;
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const graphql_1 = require("graphql");
const shared_1 = require("./shared");
exports.BABEL_GQL_GLOBAL = global;
function debug(...args) {
    if (process.env.BABEL_GQL_DEBUG) {
        console.log("[babel-gql]", ...args);
    }
}
exports.debug = debug;
function hash(s) {
    return crypto_1.default
        .createHash("sha256")
        .update(s, "utf8")
        .digest()
        .toString("hex");
}
function findUsedFragments(operation, knownFragments, _usedFragments) {
    const usedFragments = _usedFragments
        ? _usedFragments
        : new Map();
    graphql_1.visit(operation, {
        FragmentSpread: {
            enter(node) {
                const frag = knownFragments.get(node.name.value);
                if (frag) {
                    usedFragments.set(node.name.value, frag);
                    findUsedFragments(frag, knownFragments, usedFragments);
                }
                else {
                    throw new Error("Unknown fragment: " + node.name.value);
                }
            },
        },
    });
    return usedFragments;
}
exports.findUsedFragments = findUsedFragments;
function isOperationDefinition(ob) {
    return Boolean(ob && ob.kind === "OperationDefinition");
}
function isFragmentDefinition(ob) {
    return Boolean(ob && ob.kind === "FragmentDefinition");
}
class BabelGQLWebpackPlugin {
    constructor(options) {
        debug("Initializing Webpack plugin");
        if (!options.target) {
            throw new Error("No target passed to QueryManagerWebpackPlugin");
        }
        this.target = options.target;
        this.onDone = options.onDone;
        if (typeof options.active === "undefined") {
            this.active = true;
        }
        else {
            this.active = options.active;
        }
    }
    apply(compiler) {
        exports.BABEL_GQL_GLOBAL.babelGQLWebpackPlugin = true;
        compiler.hooks.done.tapPromise("BabelGQLWebpackPlugin", async () => {
            await this.handleDone().catch((error) => {
                console.error("[babel-gql] Webpack plugin failed", error);
            });
        });
    }
    async handleDone() {
        if (!QueryManager.hasRegisterdGlobal()) {
            return;
        }
        const qm = QueryManager.getRegisteredGlobal();
        await fs_1.promises.mkdir(this.target, { recursive: true });
        const allQueries = qm.getQueries();
        const dirtyQueries = qm.popDirtyQueries();
        debug(`Found ${dirtyQueries.length}/${allQueries.length} dirty queries`);
        if (dirtyQueries.length === 0) {
            return;
        }
        if (this.active) {
            await Promise.all(dirtyQueries.map(async (query) => {
                const path = path_1.default.join(this.target, `${query.queryName}-${query.fullQueryId}.graphql`);
                console.log("[babel-gql] Writing ", path);
                await fs_1.promises.writeFile(path, query.fullQuery);
            }));
        }
        if (this.onDone) {
            await this.onDone(qm, dirtyQueries.length);
        }
    }
}
exports.BabelGQLWebpackPlugin = BabelGQLWebpackPlugin;
/**
 * In memory presentation of GraphQL queries that appear in the code
 */
class QueryManager {
    constructor() {
        /**
         * Queries by name
         */
        this.knownQueries = new Map();
        /**
         * Fragments by name
         */
        this.knownFragments = new Map();
        /**
         * Fragments by query name
         */
        this.fragmentsUsedByQuery = new Map();
        /**
         * Fragments by fragment name
         */
        this.fragmentsUsedByFragment = new Map();
        this.dirtyQueries = new Set();
    }
    static getRegisteredGlobal() {
        if (!exports.BABEL_GQL_GLOBAL.babelGQLQueryManager) {
            throw new Error("[babel-gql] No global QueryManager registered. The Babel plugin is not properly configured? See https://github.com/valu-digital/babel-gql#install");
        }
        return exports.BABEL_GQL_GLOBAL.babelGQLQueryManager;
    }
    static hasRegisterdGlobal() {
        return Boolean(exports.BABEL_GQL_GLOBAL.babelGQLQueryManager);
    }
    static clearGlobal() {
        delete exports.BABEL_GQL_GLOBAL.babelGQLQueryManager;
    }
    registerAsGlobal() {
        if (exports.BABEL_GQL_GLOBAL.babelGQLQueryManager) {
            throw new Error("[babel-gql] There's already a global QueryManager defined");
        }
        exports.BABEL_GQL_GLOBAL.babelGQLQueryManager = this;
    }
    parseGraphQL(graphql) {
        const doc = graphql_1.parse(graphql);
        const queries = [];
        const fragments = [];
        graphql_1.visit(doc, {
            OperationDefinition: (def) => {
                if (!def.name) {
                    throw new Error("OperationDefinition missing name");
                }
                const queryName = def.name.value;
                const query = graphql_1.print(def).trim();
                queries.push(queryName);
                if (this.knownQueries.get(queryName) === query) {
                    debug("No changes to " + queryName);
                    // no changes
                    return;
                }
                debug("Found changes to query " + queryName);
                this.dirtyQueries.add(queryName);
                this.knownQueries.set(queryName, query);
                this.fragmentsUsedByQuery.set(queryName, new Set());
            },
            FragmentDefinition: (def) => {
                const fragmentName = def.name.value;
                const fragment = graphql_1.print(def).trim();
                fragments.push(fragmentName);
                if (this.knownFragments.get(fragmentName) === fragment) {
                    // no changes
                    return;
                }
                this.knownFragments.set(fragmentName, fragment);
                this.fragmentsUsedByFragment.set(fragmentName, new Set());
                const relatedFragments = new Set();
                relatedFragments.add(fragmentName);
                for (const [relatedFragmentName, usedFragmentNames,] of this.fragmentsUsedByFragment.entries()) {
                    if (!usedFragmentNames) {
                        continue;
                    }
                    if (usedFragmentNames.has(fragmentName)) {
                        relatedFragments.add(relatedFragmentName);
                    }
                }
                for (const [queryName, usedFragmentNames,] of this.fragmentsUsedByQuery.entries()) {
                    if (!usedFragmentNames) {
                        continue;
                    }
                    for (const usedFragmentName of usedFragmentNames) {
                        if (relatedFragments.has(usedFragmentName)) {
                            this.dirtyQueries.add(queryName);
                        }
                    }
                }
            },
            FragmentSpread: (node, key, parent, path, ancestors) => {
                var _a;
                const fragmentSpreadName = node.name.value;
                for (const a of ancestors) {
                    if (isFragmentDefinition(a)) {
                        const parentFragmentName = a.name.value;
                        let fragments = this.fragmentsUsedByFragment.get(parentFragmentName);
                        if (!fragments) {
                            fragments = new Set();
                            this.fragmentsUsedByFragment.set(parentFragmentName, fragments);
                        }
                        fragments.add(fragmentSpreadName);
                    }
                    if (isOperationDefinition(a)) {
                        const queryName = (_a = a.name) === null || _a === void 0 ? void 0 : _a.value;
                        if (!queryName) {
                            continue;
                        }
                        let fragments = this.fragmentsUsedByQuery.get(queryName);
                        if (!fragments) {
                            fragments = new Set();
                            this.fragmentsUsedByQuery.set(queryName, fragments);
                        }
                        fragments.add(fragmentSpreadName);
                    }
                }
            },
        });
        return {
            queries: queries.map((queryName) => {
                var _a;
                const query = this.knownQueries.get(queryName);
                return {
                    query,
                    queryName,
                    queryId: hash(query),
                    usedFragments: Array.from((_a = this.fragmentsUsedByQuery.get(queryName)) !== null && _a !== void 0 ? _a : []),
                };
            }),
            fragments: fragments.map((fragmentName) => {
                var _a;
                const fragment = this.knownFragments.get(fragmentName);
                return {
                    fragment,
                    fragmentName,
                    fragmentId: hash(fragment),
                    usedFragments: Array.from((_a = this.fragmentsUsedByFragment.get(fragmentName)) !== null && _a !== void 0 ? _a : []),
                };
            }),
        };
    }
    queryHasRequiredFragments(queryName) {
        const usedFragments = this.getUsedFragmentNamesForQuery(queryName);
        for (const fragmentName of usedFragments) {
            if (!this.knownFragments.has(fragmentName)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Get set of dirty queries that have all required fragments
     */
    popDirtyQueries() {
        const availableQueries = this.dirtyQueries;
        const popQueries = new Set();
        this.dirtyQueries = new Set();
        for (const queryName of availableQueries) {
            if (this.queryHasRequiredFragments(queryName)) {
                popQueries.add(queryName);
            }
            else {
                this.dirtyQueries.add(queryName);
            }
        }
        return Array.from(popQueries)
            .map((queryName) => {
            return this.exportQuery(queryName);
        })
            .filter(Boolean);
    }
    getQueries() {
        return Array.from(this.knownQueries.keys())
            .filter((queryName) => this.queryHasRequiredFragments(queryName))
            .map((queryName) => {
            return this.exportQuery(queryName);
        });
    }
    getUsedFragmentNamesForQuery(queryName) {
        const fragmentNames = new Set();
        const usedFragments = this.fragmentsUsedByQuery.get(queryName);
        if (!usedFragments) {
            return fragmentNames;
        }
        for (const usedFragmentName of usedFragments) {
            fragmentNames.add(usedFragmentName);
            this.getNestedFragmentNamesForFragment(usedFragmentName, fragmentNames);
        }
        return fragmentNames;
    }
    getNestedFragmentNamesForFragment(fragmentName, _fragments) {
        const fragments = _fragments || new Set();
        const usedFragments = this.fragmentsUsedByFragment.get(fragmentName);
        if (usedFragments) {
            for (const usedFragmentName of usedFragments) {
                fragments.add(usedFragmentName);
                this.getNestedFragmentNamesForFragment(usedFragmentName, fragments);
            }
        }
        return fragments;
    }
    exportQuery(queryName) {
        const query = this.knownQueries.get(queryName);
        if (!query) {
            throw new Error(`Unknown query ${queryName}`);
        }
        const fragments = Array.from(this.getUsedFragmentNamesForQuery(queryName))
            .map((fragmentName) => {
            const fragment = this.knownFragments.get(fragmentName);
            return {
                fragment,
                fragmentName,
                fragmentId: hash(fragment),
            };
        })
            .sort((a, b) => {
            return a.fragmentName.localeCompare(b.fragmentName);
        });
        const fragmentIds = fragments.map((f) => f.fragmentId);
        const fragmentsString = fragments.map((f) => f.fragment).join("\n");
        const fullQuery = (fragmentsString + "\n" + query).trim();
        const queryId = hash(query);
        const fullQueryId = shared_1.combinedIds([queryId, ...fragmentIds]);
        return {
            query,
            queryId,
            fullQueryId,
            fullQuery,
            usedFragments: fragments,
            queryName,
        };
    }
}
exports.QueryManager = QueryManager;
//# sourceMappingURL=query-manager.js.map