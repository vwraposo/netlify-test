import { FragmentDefinitionNode, OperationDefinitionNode } from "graphql";
import { ParsedGQLTag } from "./shared";
export declare const BABEL_GQL_GLOBAL: {
    babelGQLQueryManager: QueryManager;
    babelGQLWebpackPlugin?: boolean | undefined;
};
export declare function debug(...args: any[]): void;
export declare function findUsedFragments(operation: OperationDefinitionNode | FragmentDefinitionNode, knownFragments: ReadonlyMap<string, FragmentDefinitionNode>, _usedFragments?: Map<string, FragmentDefinitionNode>): Map<string, FragmentDefinitionNode>;
interface OnDone {
    (qm: QueryManager, modifiedQueryCount: number): Promise<any>;
}
export declare class BabelGQLWebpackPlugin {
    target: string;
    onDone?: OnDone;
    active?: boolean;
    constructor(options: {
        target: string;
        onDone?: OnDone;
        active?: boolean;
    });
    apply(compiler: any): void;
    handleDone(): Promise<void>;
}
/**
 * In memory presentation of GraphQL queries that appear in the code
 */
export declare class QueryManager {
    /**
     * Queries by name
     */
    knownQueries: Map<string, string | undefined>;
    /**
     * Fragments by name
     */
    knownFragments: Map<string, string | undefined>;
    /**
     * Fragments by query name
     */
    fragmentsUsedByQuery: Map<string, Set<string> | undefined>;
    /**
     * Fragments by fragment name
     */
    fragmentsUsedByFragment: Map<string, Set<string> | undefined>;
    dirtyQueries: Set<string>;
    static getRegisteredGlobal(): QueryManager;
    static hasRegisterdGlobal(): boolean;
    static clearGlobal(): void;
    registerAsGlobal(): void;
    parseGraphQL(graphql: string): ParsedGQLTag;
    queryHasRequiredFragments(queryName: string): boolean;
    /**
     * Get set of dirty queries that have all required fragments
     */
    popDirtyQueries(): {
        query: string;
        queryId: string;
        fullQueryId: string;
        fullQuery: string;
        usedFragments: {
            fragment: string;
            fragmentName: string;
            fragmentId: string;
        }[];
        queryName: string;
    }[];
    getQueries(): {
        query: string;
        queryId: string;
        fullQueryId: string;
        fullQuery: string;
        usedFragments: {
            fragment: string;
            fragmentName: string;
            fragmentId: string;
        }[];
        queryName: string;
    }[];
    getUsedFragmentNamesForQuery(queryName: string): Set<string>;
    getNestedFragmentNamesForFragment(fragmentName: string, _fragments?: Set<string>): Set<string>;
    exportQuery(queryName: string): {
        query: string;
        queryId: string;
        fullQueryId: string;
        fullQuery: string;
        usedFragments: {
            fragment: string;
            fragmentName: string;
            fragmentId: string;
        }[];
        queryName: string;
    };
}
export {};
