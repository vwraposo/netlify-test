"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.transformWithTs = void 0;
var tslib_1 = require("tslib");
var typescript = tslib_1.__importStar(require("typescript"));
var interpolate_name_1 = require("./interpolate-name");
var intl_messageformat_parser_1 = require("intl-messageformat-parser");
var MESSAGE_DESC_KEYS = [
    'id',
    'defaultMessage',
    'description',
];
function primitiveToTSNode(ts, v) {
    return typeof v === 'string'
        ? ts.createStringLiteral(v)
        : typeof v === 'number'
            ? ts.createNumericLiteral(v + '')
            : typeof v === 'boolean'
                ? v
                    ? ts.createTrue()
                    : ts.createFalse()
                : undefined;
}
function objToTSNode(ts, obj) {
    var props = Object.entries(obj).map(function (_a) {
        var k = _a[0], v = _a[1];
        return ts.createPropertyAssignment(k, primitiveToTSNode(ts, v) ||
            (Array.isArray(v)
                ? ts.createArrayLiteral(v.map(function (n) { return objToTSNode(ts, n); }))
                : typeof v === 'object'
                    ? objToTSNode(ts, v)
                    : ts.createNull()));
    });
    return ts.createObjectLiteral(props);
}
function messageASTToTSNode(ts, ast) {
    return ts.createArrayLiteral(ast.map(function (el) { return objToTSNode(ts, el); }));
}
var DEFAULT_OPTS = {
    onMsgExtracted: function () { return undefined; },
    onMetaExtracted: function () { return undefined; },
};
function isMultipleMessageDecl(ts, node) {
    return (ts.isIdentifier(node.expression) &&
        node.expression.text === 'defineMessages');
}
function isSingularMessageDecl(ts, node, additionalComponentNames) {
    var compNames = new Set(tslib_1.__spreadArrays([
        'FormattedMessage',
        'defineMessage'
    ], additionalComponentNames));
    var fnName = '';
    if (ts.isCallExpression(node) && ts.isIdentifier(node.expression)) {
        fnName = node.expression.text;
    }
    else if (ts.isJsxOpeningElement(node) && ts.isIdentifier(node.tagName)) {
        fnName = node.tagName.text;
    }
    else if (ts.isJsxSelfClosingElement(node) &&
        ts.isIdentifier(node.tagName)) {
        fnName = node.tagName.text;
    }
    return compNames.has(fnName);
}
function extractMessageDescriptor(ts, node, _a, sf) {
    var overrideIdFn = _a.overrideIdFn, extractSourceLocation = _a.extractSourceLocation;
    var properties = undefined;
    if (ts.isObjectLiteralExpression(node)) {
        properties = node.properties;
    }
    else if (ts.isJsxOpeningElement(node) || ts.isJsxSelfClosingElement(node)) {
        properties = node.attributes.properties;
    }
    var msg = { id: '' };
    if (!properties) {
        return;
    }
    properties.forEach(function (prop) {
        var name = prop.name;
        var initializer = ts.isPropertyAssignment(prop) || ts.isJsxAttribute(prop)
            ? prop.initializer
            : undefined;
        if (name && ts.isIdentifier(name) && initializer) {
            if (ts.isStringLiteral(initializer)) {
                switch (name.text) {
                    case 'id':
                        msg.id = initializer.text;
                        break;
                    case 'defaultMessage':
                        msg.defaultMessage = initializer.text;
                        break;
                    case 'description':
                        msg.description = initializer.text;
                        break;
                }
            }
            else if (ts.isNoSubstitutionTemplateLiteral(initializer)) {
                switch (name.text) {
                    case 'id':
                        msg.id = initializer.text;
                        break;
                    case 'defaultMessage':
                        msg.defaultMessage = initializer.text;
                        break;
                    case 'description':
                        msg.description = initializer.text;
                        break;
                }
            }
            else if (ts.isJsxExpression(initializer) &&
                initializer.expression &&
                ts.isNoSubstitutionTemplateLiteral(initializer.expression)) {
                var expression = initializer.expression;
                switch (name.text) {
                    case 'id':
                        msg.id = expression.text;
                        break;
                    case 'defaultMessage':
                        msg.defaultMessage = expression.text;
                        break;
                    case 'description':
                        msg.description = expression.text;
                        break;
                }
            }
        }
    });
    // We extracted nothing
    if (!msg.defaultMessage && !msg.id) {
        return;
    }
    if (msg.defaultMessage) {
        msg.defaultMessage = msg.defaultMessage.trim().replace(/\s+/gm, ' ');
    }
    if (msg.defaultMessage && overrideIdFn) {
        switch (typeof overrideIdFn) {
            case 'string':
                if (!msg.id) {
                    msg.id = interpolate_name_1.interpolateName({ sourcePath: sf.fileName }, overrideIdFn, {
                        content: msg.description
                            ? msg.defaultMessage + "#" + msg.description
                            : msg.defaultMessage,
                    });
                }
                break;
            case 'function':
                msg.id = overrideIdFn(msg.id, msg.defaultMessage, msg.description, sf.fileName);
                break;
        }
    }
    if (extractSourceLocation) {
        return tslib_1.__assign(tslib_1.__assign({}, msg), { file: sf.fileName, start: node.pos, end: node.end });
    }
    return msg;
}
/**
 * Check if node is `intl.formatMessage` node
 * @param node
 * @param sf
 */
function isIntlFormatMessageCall(ts, node) {
    var method = node.expression;
    // Handle intl.formatMessage()
    if (ts.isPropertyAccessExpression(method)) {
        return ((method.name.text === 'formatMessage' &&
            ts.isIdentifier(method.expression) &&
            method.expression.text === 'intl') ||
            (ts.isPropertyAccessExpression(method.expression) &&
                method.expression.name.text === 'intl'));
    }
    // Handle formatMessage()
    return ts.isIdentifier(method) && method.text === 'formatMessage';
}
function extractMessageFromJsxComponent(ts, node, opts, sf) {
    var onMsgExtracted = opts.onMsgExtracted;
    if (!isSingularMessageDecl(ts, node, opts.additionalComponentNames || [])) {
        return node;
    }
    var msg = extractMessageDescriptor(ts, node, opts, sf);
    if (!msg) {
        return node;
    }
    if (typeof onMsgExtracted === 'function') {
        onMsgExtracted(sf.fileName, [msg]);
    }
    var attrs = setAttributesInJsxAttributes(ts, node.attributes, {
        defaultMessage: opts.removeDefaultMessage
            ? undefined
            : msg.defaultMessage,
        id: msg.id,
    }, opts.ast);
    return ts.isJsxOpeningElement(node)
        ? ts.createJsxOpeningElement(node.tagName, node.typeArguments, attrs)
        : ts.createJsxSelfClosingElement(node.tagName, node.typeArguments, attrs);
}
function setAttributesInObject(ts, node, msg, ast) {
    var newProps = tslib_1.__spreadArrays([
        ts.createPropertyAssignment('id', ts.createStringLiteral(msg.id))
    ], (msg.defaultMessage
        ? [
            ts.createPropertyAssignment('defaultMessage', ast
                ? messageASTToTSNode(ts, intl_messageformat_parser_1.parse(msg.defaultMessage))
                : ts.createStringLiteral(msg.defaultMessage)),
        ]
        : []));
    for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isPropertyAssignment(prop) &&
            ts.isIdentifier(prop.name) &&
            MESSAGE_DESC_KEYS.includes(prop.name.text)) {
            continue;
        }
        if (ts.isPropertyAssignment(prop)) {
            newProps.push(prop);
        }
    }
    return ts.createObjectLiteral(ts.createNodeArray(newProps));
}
function setAttributesInJsxAttributes(ts, node, msg, ast) {
    var newProps = tslib_1.__spreadArrays([
        ts.createJsxAttribute(ts.createIdentifier('id'), ts.createStringLiteral(msg.id))
    ], (msg.defaultMessage
        ? [
            ts.createJsxAttribute(ts.createIdentifier('defaultMessage'), ast
                ? ts.createJsxExpression(undefined, messageASTToTSNode(ts, intl_messageformat_parser_1.parse(msg.defaultMessage)))
                : ts.createStringLiteral(msg.defaultMessage)),
        ]
        : []));
    for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (ts.isJsxAttribute(prop) &&
            ts.isIdentifier(prop.name) &&
            MESSAGE_DESC_KEYS.includes(prop.name.text)) {
            continue;
        }
        if (ts.isJsxAttribute(prop)) {
            newProps.push(prop);
        }
    }
    return ts.createJsxAttributes(ts.createNodeArray(newProps));
}
function extractMessagesFromCallExpression(ts, node, opts, sf) {
    var onMsgExtracted = opts.onMsgExtracted;
    if (isMultipleMessageDecl(ts, node)) {
        var _a = node.arguments, arg = _a[0], restArgs = _a.slice(1);
        var descriptorsObj = void 0;
        if (ts.isObjectLiteralExpression(arg)) {
            descriptorsObj = arg;
        }
        else if (ts.isAsExpression(arg) &&
            ts.isObjectLiteralExpression(arg.expression)) {
            descriptorsObj = arg.expression;
        }
        if (descriptorsObj) {
            var properties = descriptorsObj.properties;
            var msgs_1 = properties
                .filter(function (prop) {
                return ts.isPropertyAssignment(prop);
            })
                .map(function (prop) {
                return ts.isObjectLiteralExpression(prop.initializer) &&
                    extractMessageDescriptor(ts, prop.initializer, opts, sf);
            })
                .filter(function (msg) { return !!msg; });
            if (!msgs_1.length) {
                return node;
            }
            if (typeof onMsgExtracted === 'function') {
                onMsgExtracted(sf.fileName, msgs_1);
            }
            var clonedProperties = ts.createNodeArray(properties.map(function (prop, i) {
                if (!ts.isPropertyAssignment(prop) ||
                    !ts.isObjectLiteralExpression(prop.initializer)) {
                    return prop;
                }
                return ts.createPropertyAssignment(prop.name, setAttributesInObject(ts, prop.initializer, {
                    defaultMessage: opts.removeDefaultMessage
                        ? undefined
                        : msgs_1[i].defaultMessage,
                    id: msgs_1[i] ? msgs_1[i].id : '',
                }, opts.ast));
            }));
            var clonedDescriptorsObj = ts.createObjectLiteral(clonedProperties);
            return ts.createCall(node.expression, node.typeArguments, ts.createNodeArray(tslib_1.__spreadArrays([clonedDescriptorsObj], restArgs)));
        }
    }
    else if (isSingularMessageDecl(ts, node, opts.additionalComponentNames || []) ||
        (opts.extractFromFormatMessageCall && isIntlFormatMessageCall(ts, node))) {
        var _b = node.arguments, descriptorsObj = _b[0], restArgs = _b.slice(1);
        if (ts.isObjectLiteralExpression(descriptorsObj)) {
            var msg = extractMessageDescriptor(ts, descriptorsObj, opts, sf);
            if (!msg) {
                return node;
            }
            if (typeof onMsgExtracted === 'function') {
                onMsgExtracted(sf.fileName, [msg]);
            }
            return ts.createCall(node.expression, node.typeArguments, ts.createNodeArray(tslib_1.__spreadArrays([
                setAttributesInObject(ts, descriptorsObj, {
                    defaultMessage: opts.removeDefaultMessage
                        ? undefined
                        : msg.defaultMessage,
                    id: msg.id,
                }, opts.ast)
            ], restArgs)));
        }
    }
    return node;
}
var PRAGMA_REGEX = /^\/\/ @([^\s]*) (.*)$/m;
function getVisitor(ts, ctx, sf, opts) {
    var visitor = function (node) {
        var newNode = ts.isCallExpression(node)
            ? extractMessagesFromCallExpression(ts, node, opts, sf)
            : ts.isJsxOpeningElement(node) || ts.isJsxSelfClosingElement(node)
                ? extractMessageFromJsxComponent(ts, node, opts, sf)
                : node;
        return ts.visitEachChild(newNode, visitor, ctx);
    };
    return visitor;
}
function transformWithTs(ts, opts) {
    opts = tslib_1.__assign(tslib_1.__assign({}, DEFAULT_OPTS), opts);
    var transformFn = function (ctx) {
        return function (sf) {
            var pragmaResult = PRAGMA_REGEX.exec(sf.text);
            if (pragmaResult) {
                var pragma = pragmaResult[1], kvString = pragmaResult[2];
                if (pragma === opts.pragma) {
                    var kvs = kvString.split(' ');
                    var result = {};
                    for (var _i = 0, kvs_1 = kvs; _i < kvs_1.length; _i++) {
                        var kv = kvs_1[_i];
                        var _a = kv.split(':'), k = _a[0], v = _a[1];
                        result[k] = v;
                    }
                    if (typeof opts.onMetaExtracted === 'function') {
                        opts.onMetaExtracted(sf.fileName, result);
                    }
                }
            }
            return ts.visitNode(sf, getVisitor(ts, ctx, sf, opts));
        };
    };
    return transformFn;
}
exports.transformWithTs = transformWithTs;
function transform(opts) {
    return transformWithTs(typescript, opts);
}
exports.transform = transform;
